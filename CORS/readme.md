# 디자인 패턴

### 디자인 패턴이란?

- 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계등을 이용하여 해결할 수 있도록 하나의 “규약” 형태로 만들어 놓은 것을 의미한다.

## 1. 싱글톤 패턴

- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴.
- 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는 데 쓰이며, 보통은 데이터베이스 연결 모듈에 많이 사용한다.
- 하나의 인스턴스를 만들어 놓고, 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에, **인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있다.**
- 하지만 의존성이 높아진다.

### 1-2. 자바스크립트의 싱글톤 패턴

- 보통은 DB 연결할때 많이 쓰인다.

### 1-3. 싱글톤 패턴의 단점

- 싱글톤 패턴은 TDD를 할 때 걸림돌이 된다.
- TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행 할 수 있어야한다.

<aside>
🚨 하지만 **싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴**이므로 각 테스트마다 **“독립적인” 인스턴스를 만들기 어렵다.**

</aside>

### 1-4. 의존성 주입

- 싱글톤 패턴은 모듈간의 결합을 강하게 만들 수 있다는 단점이 있다.

<aside>
🚨 이때 의존성 주입을 사용하면 모듈간의 결합을 조금 더 느슨하게 만들 수 있다.

</aside>

- static 키워드를 통해 메서드를 생성하게 되면 `(정적 메서드)`, 클래스 기반으로 객체를 만들지 않고 호출이 가능하며, 해당 메서드에 대한 메모리 할당을 한 번만 할 수 있다는 장점.

## 2. 팩토리 패턴

## 3. 전략 패턴

## 4. 옵저버 패턴

- 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다.
- 주체란? 객체의 상태 변화를 보고 있는 관찰자이
- 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들을 의미한다.

<aside>
💡 옵저버 패턴을 활용한 서비스로는 트위터가 있다.

</aside>

## 5. 프록시 패턴과 프록시 서버

### 프록시 패턴

- 프록시 객체는 사실 디자인 패턴 중 하나인 프록시 패턴이 녹아들어 있는 객체이다.
- 프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다.

### 프록시 서버

- 프록시 서버는 **서버와 클라이언트 사이**에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.

- 프록시 서버로 쓰는 nginx
  - nginx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 Node.js 서버 앞단의 프록시 서버로 활용된다.
- ‘Node.js’의 버퍼 오버플로우 취약점을 예방하기 위해서는 nginx를 ‘프록시 서버’로 앞단에 놓고 Node.js를 뒤쪽에 놓는것이 좋다.( nginx가 프록시 서버로 됨 ) Node.js는 실제 웹 서버

<aside>
💡 이런한 말은 Node.js 서버를 운영할때 교과서 처럼 참고되어 많은 사람이 이렇게 구축하고 있다.

</aside>

**해결책**

- 익명 사용자가 직접적으로 서버에 접근하는 것을 차단한다.
- 간접적으로 한 단계를 더 거치게 만들어서 보안을 강화할 수 있다.
- nginx를 프록시 서버로 둬서 실제 포트를 숨길수 있다
- 정적자원을 gzip압축 하거나
- 메인 서버 앞단에서의 로깅을 할 수 있다.

### 프록시 서버로 쓰는 CloudFlare

- CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 컨텐츠 전달을 빠르게 할 수 있는 CDN 서비스 이다.
- 서비스를 배포한 이후에 해외에서 무언가 의심스러운 트래픽이 많이 발생하면 이 때문에 많은 클라우드 서비스 비용이 발생할 수도 있는데, 이때 **CloudFlare가 의심스러운 트래픽인지를 먼저 판단해 CAPTCHA등을 기반으로 이를 일정 부분 막아주는 역할도 수행한다.**

<aside>
💡 앞의 그림처럼 사용자, 크롤러, 공격자가 자신의 웹 사이트에 접속하게 될 텐데, **이때 CloudFlare를 통해 공격자로부터 보호 할 수 있다.**

</aside>

### DDOS 공격 방어

- DDOS는 **짧은 기간 동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜** 웹 사이트의 가용성을 방해하는 사이버 공격 유형이다.
- CloudFlare는 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로 부터 보호한다.
- 소규모 DDOS 공격은 쉽게 막아낼 수 있다.

### HTTPS 구축

- 서버에서 HTTPS를 구축할 때 인증서를 기반으로 구축할 수도 있다. 하지만 CloudFlare를 사용하면 별도의 인증서 설치 없이 좀 더 손쉽게 HTTPS를 구축 할 수 있다.

### CDN

- 사용자가 인터넷을 접속하는 곳과 물리적으로 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다.

<aside>
💡 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드하는 시간을 줄 일 수 있다.

</aside>

### CORS와 프런트엔드의 프록시 서버

[교차 출처 리소스 공유 (CORS) - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/CORS)

- CORS는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
- 다른 오리진간에 리소스를 공유할 수 있도록 하는 메커니즘.
- 서버측 express, spring, 장고등에서 CORS 옵션을 넣는 방법들이 쉽게 마련되어있다. (명시해 주면된다.) 거기서 지정한 사이트에서는 HTTP 요청을 보낼수 있다.
- 포트 번호가 다르면 CORS가 난다.

<aside>
💡 예를들어 프론트에서는 `127.0.0.1:3000` 으로 로컬 테스트를 하고 있는데, 백엔드 서버는 `127.0.0.1:12010` 이라면 포트번호가 다르기 때문에 CORS 에러가 난다.

</aside>

- 이때 프록시 서버를 둬서 프론트엔드 서버에서 요청을 보낼때 오리진을 `127.0.0.1:12010` 으로 바꾼다.
  - 127.0.0.1이란 루프백 IP로 본인 PC 서버의 IP를 뜻한다.
  - localhost나 127.0.0.1을 주소창에 입력하면 DNS를 거치치 않고 자기 PC 서버로 연결된다.
- 오리진 : 프로토콜과 호스트의 이름, 포트의 조합을 말한다. `https//kundol.com:12010/test` 라는 주소에서 오리진은 `https://kundol.com:12010`을 뜻한다.

### CORS를 해결하기 위한 2가지 방법

1. 프론트엔드에서 프록시 서버를 두고 웹 서버와 같은 설정을하여 CORS를 해결
2. 서버에서 cors + origin 설정을 한다. (결국에는 운영환경, testing 환경때문에 서버에서 cors 설정을 해줘야한다.)

### Preflight request

- GET, HEAD, POST , Content-type, application, multipart, text/plain 은 Simple request라고 한다.
- 이게 아니라면 `Preflight request` option 메서드로 CORS인지 한 번 더 요청을 하게 된다.
  - 예를들어 put이나 delete 같은 메서드들은 조금 위험하기 때문에 브라우저에서 한번 더 요청을 한다.
